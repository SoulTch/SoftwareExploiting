#include "pin.H"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <stack>
#include <map>
#include <unistd.h>

#if defined(TARGET_MAC)
#define MALLOC "_malloc"
#define FREE "_free"
#else
#define MALLOC "malloc"
#define FREE "free"
#endif


//#if __x86_64__
//#elif
//#endif

std::ofstream TraceFile;
std::stack<ADDRINT> retstack[70000];
std::map<ADDRINT, ADDRINT> mallocmap;
ADDRINT lastsize;

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "pinatrace.out", "specify trace file name");
KNOB<BOOL> KnobValues(KNOB_MODE_WRITEONCE, "pintool",
    "values", "1", "Output memory values reads and written");

static INT32 Usage()
{
    cerr <<"This tool protects stack/heap overflow\n";
    cerr << KNOB_BASE::StringKnobSummary();
    cerr << endl;
    return -1;
}

VOID killProcess(string msg) {
	cerr << "Program Killed : " << msg << endl;
	PIN_ExitProcess(1);
}

VOID CallAnalysis(ADDRINT cur, ADDRINT nxt, ADDRINT instSize) {
	cerr << "CALL BY : " << PIN_GetPid() << endl;
	retstack[PIN_GetPid()].push(cur);
}

VOID RetAnalysis(ADDRINT nxt) {
	cerr << "RET BY : " << PIN_GetPid() << endl;
	if (retstack[PIN_GetPid()].empty()) killProcess("Stack frame corrupted");
	ADDRINT t = retstack[PIN_GetPid()].top(); retstack[PIN_GetPid()].pop();
	if (t != nxt) killProcess("Stack frame Corrupted");
}

VOID HeapOverflowDetection(ADDRINT addr) {
	PIN_LockClient();
	IMG img = IMG_FindByAddress(addr);
	PIN_UnlockClient();

	//cerr << hex << addr << " : " << hex << rsp << endl;
	if (addr > 0x700000000000) return;

	for(SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)){
		//cerr << "asdfa" << endl;
    	if (addr >= SEC_Address(sec) && addr < (SEC_Address(sec) + SEC_Size(sec)))
    		return;
  	}
	if (mallocmap.lower_bound(addr) -> second <= addr) {
		//killProcess("Not Allocated");
	}
}

VOID Instruction(INS ins, VOID *v)
{
	if(INS_IsCall(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) CallAnalysis,
			IARG_ADDRINT, 	INS_NextAddress(ins),
			IARG_BRANCH_TARGET_ADDR,
			IARG_ADDRINT,		INS_Size(ins),
			IARG_END);
	} else if (INS_IsRet(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) RetAnalysis,
			IARG_BRANCH_TARGET_ADDR,
			IARG_END);
	}
	/*
	else if (INS_IsMemoryWrite(ins) && INS_IsStandardMemop(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) HeapOverflowDetection,
			IARG_MEMORYWRITE_EA,
			IARG_END);
	}*/
}

VOID MallocBefore(ADDRINT size) {
	return;
	cerr << "MALLOC : ";
	lastsize = size;
}

VOID MallocAfter(ADDRINT pt) {
	return;
	if (pt == 0) return;
	if (mallocmap.find(pt) != mallocmap.end()) {
		cerr << "DUPLICATED ADDRESS?" << endl;
	}
	cerr << hex << pt << " SZ : " << lastsize << endl;
	mallocmap[pt] = pt + lastsize;
}

VOID FreeBefore(ADDRINT pt) {
	return;
	if (pt == 0) return;
	auto p = mallocmap.find(pt);
	cerr << "FREED  : " << hex << pt;
	if (p == mallocmap.end()) killProcess("Double Free");
	mallocmap.erase(p);
}

VOID FreeAfter() {
	return;
	cerr << " DONE." << endl;
}

VOID Image(IMG img, VOID *v)
{
    RTN mallocRtn = RTN_FindByName(img, MALLOC);
    if (RTN_Valid(mallocRtn))
    {
        RTN_Open(mallocRtn);
        RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)MallocBefore,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter,
                       IARG_FUNCRET_EXITPOINT_VALUE, IARG_END);
        RTN_Close(mallocRtn);
    }
/*
    RTN freeRtn = RTN_FindByName(img, FREE);
    if (RTN_Valid(freeRtn))
    {
        RTN_Open(freeRtn);
        RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)FreeBefore,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
		RTN_InsertCall(freeRtn, IPOINT_AFTER, (AFUNPTR) FreeAfter,
					   IARG_END);
        RTN_Close(freeRtn);
    }*/
}


VOID Fini(INT32 code, VOID *v)
{
    TraceFile << "#eof" << endl;
    
    TraceFile.close();
}

pid_t parent_pid;
PIN_LOCK lock;

VOID BeforeFork(THREADID threadid, const CONTEXT* ctxt, VOID * arg)
{
    //GetLock(&lock, threadid+1);
    cerr << "TOOL: Before fork." << endl;
    //ReleaseLock(&lock);
    //parent_pid = PIN_GetPid();
}


VOID AfterForkInChild(THREADID threadid, const CONTEXT* ctxt, VOID * arg)
{
	cerr << "FORK!" << endl;
    retstack[PIN_GetPid()] = retstack[getppid()];
}

int main(int argc, char *argv[])
{
    string trace_header = string("#\n"
                                 "# Overflow Detection By Pin\n"
                                 "#\n");
	PIN_InitSymbols();    
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile.write(trace_header.c_str(),trace_header.size());
    TraceFile.setf(ios::showbase);
   	
	//IMG_AddInstrumentFunction(Image, 0);
    INS_AddInstrumentFunction(Instruction, 0);

	//PIN_AddForkFunction(FPOINT_BEFORE, BeforeFork, 0);
    //PIN_AddForkFunction(FPOINT_AFTER_IN_CHILD, AfterForkInChild, 0);   
	PIN_AddFiniFunction(Fini, 0);
    PIN_StartProgram();
    
    return 0;
}
