#include "pin.H"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <stack>
#include <map>

#if defined(TARGET_MAC)
#define MALLOC "_malloc"
#define FREE "_free"
#else
#define MALLOC "malloc"
#define FREE "free"
#endif


//#if __x86_64__
//#elif
//#endif

std::ofstream TraceFile;
std::stack<ADDRINT> retstack;
std::map<ADDRINT, ADDRINT> mallocmap;
ADDRINT lastsize;

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "pinatrace.out", "specify trace file name");
KNOB<BOOL> KnobValues(KNOB_MODE_WRITEONCE, "pintool",
    "values", "1", "Output memory values reads and written");

static INT32 Usage()
{
    cerr <<"This tool protects stack/heap overflow\n";
    cerr << KNOB_BASE::StringKnobSummary();
    cerr << endl;
    return -1;
}

VOID killProcess(string msg) {
	cerr << "Program Killed : " << msg << endl;
	PIN_ExitProcess(1);
}

VOID CallAnalysis(ADDRINT cur, ADDRINT nxt, USIZE instSize) {
	retstack.push(cur);
}

VOID RetAnalysis(ADDRINT nxt) {
	if (retstack.empty()) killProcess("Stack frame corrupted");
	ADDRINT t = retstack.top(); retstack.pop();
	if (t != nxt) killProcess("Stack frame Corrupted");
}

VOID HeapOverflowDetection(ADDRINT addr) {
	PIN_LockClient();
	IMG img = IMG_FindByAddress(addr);
	PIN_UnlockClient();

	//cerr << hex << addr << " : " << hex << rsp << endl;
	if (sizeof(ADDRINT*) == 4) {
		if (addr > 0xf0000000) return;
	} else {
		if (addr > 0x700000000000) return;
	}

	for(SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)){
		//cerr << "asdfa" << endl;
    	if (addr >= SEC_Address(sec) && addr < (SEC_Address(sec) + SEC_Size(sec)))
    		return;
  	}
	if (mallocmap.lower_bound(addr) -> second <= addr) {
		//killProcess("Not Allocated");
		cerr << "HEAP OVERFLOW? : " << addr << endl;
	}
}

VOID Instruction(INS ins, VOID *v)
{
	if(INS_IsCall(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) CallAnalysis,
			IARG_ADDRINT, 	INS_NextAddress(ins),
			IARG_BRANCH_TARGET_ADDR,
			IARG_UINT64,		INS_Size(ins),
			IARG_END);
	} else if (INS_IsRet(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) RetAnalysis,
			IARG_BRANCH_TARGET_ADDR,
			IARG_END);
	} else if (INS_IsMemoryWrite(ins) && INS_IsStandardMemop(ins)) {
		INS_InsertPredicatedCall(
			ins, IPOINT_BEFORE, (AFUNPTR) HeapOverflowDetection,
			IARG_MEMORYWRITE_EA,
			IARG_END);
	}
}

VOID MallocBefore(ADDRINT size) {
	lastsize = size;
}

VOID MallocAfter(ADDRINT pt) {
	if (pt == 0) return;
	if (mallocmap.find(pt) != mallocmap.end()) {
		cerr << "DUPLICATED ADDRESS?" << endl;
	}
	cerr << "MALLOC : " << hex << pt << " SZ : " << lastsize << endl;
	mallocmap[pt] = pt + lastsize;
}

VOID FreeBefore(ADDRINT pt) {
	if (pt == 0) return;
	auto p = mallocmap.find(pt);
	cerr << "FREED  : " << hex << pt << endl;
	if (p == mallocmap.end()) // MALLOC KILL DISABLED : killProcess("Double Free");
		cerr << "DOUBLE FREE DETECTED ? " << endl;
	else mallocmap.erase(p);
}

VOID Image(IMG img, VOID *v)
{
    RTN mallocRtn = RTN_FindByName(img, MALLOC);
    if (RTN_Valid(mallocRtn))
    {
        RTN_Open(mallocRtn);
        RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)MallocBefore,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter,
                       IARG_FUNCRET_EXITPOINT_VALUE, IARG_END);
        RTN_Close(mallocRtn);
    }

    RTN freeRtn = RTN_FindByName(img, FREE);
    if (RTN_Valid(freeRtn))
    {
        RTN_Open(freeRtn);
        RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)FreeBefore,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_Close(freeRtn);
    }
}


VOID Fini(INT32 code, VOID *v)
{
    TraceFile << "#eof" << endl;
    
    TraceFile.close();
}

int main(int argc, char *argv[])
{
    string trace_header = string("#\n"
                                 "# Overflow Detection By Pin\n"
                                 "#\n");
	PIN_InitSymbols();    
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile.write(trace_header.c_str(),trace_header.size());
    TraceFile.setf(ios::showbase);
   	
	IMG_AddInstrumentFunction(Image, 0);
    INS_AddInstrumentFunction(Instruction, 0);

    PIN_AddFiniFunction(Fini, 0);

    PIN_StartProgram();
    
    return 0;
}
